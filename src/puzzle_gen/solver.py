from llm_client import get_candidate_words
from random import shuffle
from pathlib import Path
import json
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Loads the word-list.json file from the public folder
def load_word_list():
    word_list_path = Path(__file__).parent.parent.parent / "public" / "word-list.json"
    with open(word_list_path, "r") as f:
        return json.load(f)

# Builds a prefix dictionary for word backtracking, used to identify characters to match
# in the crossword puzzle
def build_prefix_dict(words):
    prefix_dict = {} 
    for word in words:
        for i in range(len(word) + 1):  # include empty prefix and full word
            prefix = word[:i]
            prefix_dict.setdefault(prefix, []).append(word)
    return prefix_dict

# Generates a crossword puzzle
def generate_crossword(theme: str = "", regenerate: bool = False, max_words: int = 100, max_attempts: int = 15, theme_words: int = 3,
                      word_tokens: int = 500):
    best_solution = None # Best possible solution (most generated words)
    best_theme_count = -1 # How many themed words are in the best solution
    attempts = max_attempts # How many attempts to find crossword w/ at least 3 gen. words
    
    # Initialize generated words set
    generated_words = set() # Words generated by AI
    database_words = set(load_word_list()) # Words from database
    regen_count = 0 # How many times more words were regenerated

    for attempt in range(attempts):
        # Generates AI words on first attempt. If regenerate parameter is True, a more expensive (time and API) method will be used
        # where the database will continuously add words
        if regenerate or regen_count == 0:
            new_words = set(
                word.upper() 
                for word in get_candidate_words(theme, words_to_avoid=list(generated_words), num_words=max_words, tokens=word_tokens) 
                if len(word) == 5
            )
            regen_count += 1
            logger.info("Generated words: " + str(new_words))
            generated_words.update(new_words)

        # Convert to list for ordering
        generated_words_list = list(generated_words)
        shuffle(generated_words_list)

        # Debug output for counts
        logger.info(f"Attempt {attempt + 1}/{attempts}")
        logger.info(f"Generated words (cumulative): {len(generated_words_list)}")
        logger.info(f"Database words: {len(database_words)}")
        
        # Form the candidate words:
        # Exclude any word already in generated_words from the wordbank.
        wordbank_words = [word for word in database_words if word not in generated_words]
        # Shuffle them to maintain randomness of generations
        shuffle(wordbank_words)
        # Add them to the end of the generated word list (so generated words are more prioritized)
        candidate_words = generated_words_list + wordbank_words
        logger.info(f"Total unique words: {len(candidate_words)}") # More debug outputs
        solution = None # Current solution being worked on
        prefix_dict = build_prefix_dict(candidate_words) # Builds a large dictionary used to identify characters to match
                                                         # in the crossword puzzle
        grid = []         # List of chosen words for rows (across)
        used = set()      # To ensure we don't reuse any words

        def backtrack(row):
            nonlocal solution
            # If we have filled all rows, check the vertical words.
            if solution is not None:
                return
            if row == 5:
                # Build vertical words (columns).
                vertical = [
                    "".join(grid[r][c] for r in range(5))
                    for c in range(5)
                ]
                # Check that each vertical word is in our word list.
                if all(v in candidate_words for v in vertical):
                    # Check overall that all words (across and down) are unique.
                    all_words = set(grid + vertical)
                    if len(all_words) == 5 * 2:
                        solution = (grid.copy(), vertical)
                return
            
            # Try each candidate word as the next across word.
            for candidate in candidate_words:
                if candidate in used:
                    continue  # don't reuse an across word
                
                grid.append(candidate)
                used.add(candidate)
                
                # Check that each column (vertical so far) is a prefix of some allowed word.
                valid = True
                for c in range(5):
                    # Build the prefix for column c from rows 0..row.
                    prefix = "".join(grid[r][c] for r in range(row + 1))
                    if prefix not in prefix_dict:
                        valid = False
                        break
                if valid:
                    backtrack(row + 1)
                
                # Backtrack, remove the last word and the used word
                grid.pop()
                used.remove(candidate)
                if solution is not None:
                    break
        backtrack(0)

        # If a solution is found, count the number of theme words
        if solution:
            logger.info(solution)
            # Count how many theme words are in the first solution
            theme_words_count = sum(1 for word in solution[0] if word in generated_words) + sum(1 for word in solution[1] if word in generated_words)
            logger.info(f"Found solution with {theme_words_count} theme words")
            
            # Update best solution if this one has more theme words
            if theme_words_count > best_theme_count:
                best_solution = solution[0]  # Take the first solution found
                best_theme_count = theme_words_count
                
            # If we found a solution with the goal count of theme words, we can stop
            if theme_words_count >= theme_words:
                logger.info(f"Found solution with {theme_words_count} theme words!")
                return solution[0]
        
        logger.info(f"Best solution so far has {best_theme_count} theme words")
    
    if best_solution:
        logger.info(f"Returning best solution found with {best_theme_count} theme words")
    else:
        logger.info("No solutions found in any attempt")
    return best_solution

# Test case
if __name__ == "__main__":
    try:
        solution = generate_crossword("car brands", regenerate=False) # Test Case : "car brands"
        if solution:
            logger.info("\nFound a word square:")
            for word in solution:  # Print each word in the solution
                logger.info(word)
        else:
            logger.info("\nNo solution found.")
    except Exception as e:
        logger.error(f"\nError occurred: {e}")
